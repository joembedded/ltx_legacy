<?php
/*
 * lxu_ltxlora_v1.php
 *
 * This script serves as an HTTP(s) uploader for ltx payloads (see https://github.com/joembedded/payload-decoder) 
 * to the ltx-microcloud.
 *
 * It supports both ChirpStack and TTN and processes incoming JSON data sent via POST.
 *
 * Main functions:
 * - Reception and validation of JSON payloads containing sensor data.
 * - Authentication via an API key (parameter KEY).
 * - Extraction and storage of measurement data, metadata, and device status.
 * - Management of daily quotas and transmission counters per device.
 * - Automatic logging and optional triggering of further processes.
 * - Error handling with JSON error messages.
 *
 * Notes:
 * - Only payloads with valid data ($data) are processed and triggered.
 * - For debugging purposes, the complete payload can be logged.
 * - New devices are automatically generated by the ltx-microcloud
 *
 * Example call (add this as webhook):
 *   server.abc/ltx/sw/lxu_ltxlora_v1.php?KEY=xxxx
 *   (Data as JSON in the HTTP body)
 *
 * V1.02 - 26.06.2025 (C) JoEmbedded.de
 */

error_reporting(E_ALL);
ini_set("display_errors", true);
ignore_user_abort(true);
date_default_timezone_set('UTC'); // for strtotime
header("Content-Type: application/json");

include("conf/api_key.inc.php");
include("lxu_loglib.php");

//------------ Functions ----------------
function exit_json_error($errmsg)
{ // Also used as regular exit_json_error()
	http_response_code(400);
	echo json_encode(['error' => $errmsg]);
	exit;
}

function call_trigger($mac, $reason)
{
	global $dbg;
	$self = $_SERVER['PHP_SELF'];
	$port = $_SERVER['SERVER_PORT'];
	$isHttps =  (isset($_SERVER['HTTPS']) && $_SERVER['HTTPS'] === 'on')  || (isset($_SERVER['SERVER_PORT']) && (int) $_SERVER['SERVER_PORT'] === 443);
	if ($isHttps) $server = "https://";
	else $server = "http://";
	$server .= $_SERVER['SERVER_NAME'];
	$rpos = strrpos($self, '/'); // Same level
	$tscript = substr($self, 0, $rpos) . "/lxu_trigger.php";
	$arg = "k=" . S_API_KEY . "&r=$reason&s=$mac";    // Parameters: API-KEY, reason and MAC
	$clog = "(trigger(MAC:$mac: Reason:$reason))";
	$ch = curl_init("$server:$port$tscript?$arg");
	curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
	curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 2);
	curl_setopt($ch, CURLOPT_TIMEOUT, 1);
	$result = curl_exec($ch);
	if ($dbg) {
		$rlen = strlen(@$result);
		if ($rlen > 80) $sres = substr(@$result, 0, 80) . '...';
		else $sres = $result;
		$clog .= "(Curl:trigger: [$rlen]'$sres')";
	}
	if (curl_errno($ch)) {
		$clog = '(ERROR: Curl:' . curl_error($ch) . ')';
	}
	curl_close($ch);
	return $clog;
}

// Read/Write INI-File - Returns empty array if not existent. 
// Still old system with KeyValue
function read_ini($fname)
{
	$devi = array();
	if (file_exists($fname)) {
		$lines = file("$fname", FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);
		foreach ($lines as $line) {
			$tmp = explode("\t", $line);
			$devi[$tmp[0]] = $tmp[1];
		}
	}
	return $devi;
}
function write_ini($fname, &$devi)
{
	$of = fopen($fname, 'w');
	while (!flock($of, LOCK_EX)) usleep(10000);  // Lock file - Is a MUST
	foreach ($devi as $key => $val) {
		fwrite($of, "$key\t$val\n");
	}
	fclose($of);
}
// Write content data into LEGACY directory
function add_data($cont)
{
	global $xlog, $dpath;
	if (@filesize("$dpath/files/data.edt") > 1000000) {    // 2*1MB per device maximum
		@unlink("$dpath/files/data.edt.bak");
		@rename("$dpath/files/data.edt", "$dpath/files/data.edt.bak");
		$xlog .= " ('data.edt' -> '/data.edt.bak')";
	}
	@file_put_contents("$dpath/files/data.edt", $cont, FILE_APPEND);
}


//============ MAIN ===================
$dbg = 0; // Debug level if >0, see docu

try {

	$result = "success";
	$paylog = false;	// If true: log if necessary, helps to find invalid packets
	$paytrigger = true;	// Start trigger if OK

	$api_key = @$_GET['KEY'] ?? '';;

	$now = time();                        // one timestamp for complete run
	$now_str = gmdate("Y-m-d H:i:s", $now); // Readable (UTC)
	$mtmain_t0 = microtime(true);         // for benchmark 
	$dfn = gmdate("Ymd_His", $now);        // 'disk_filename_from_now' (sortable)

	// Get the body of the POST request
	$payload = file_get_contents("php://input");

	// Convert the JSON payload into an array
	$data = json_decode($payload, true);

	// Chirpstack_or_TTN START - Get posted data
	$devEui = $data['deviceInfo']['devEui'] ?? $data['end_device_ids']['dev_eui'] ?? null;

	if (!isset($devEui)) exit_json_error("Invalid Payload");
	$mac = strtoupper($devEui);
	if (!isset($mac) || strlen($mac) != 16) exit_json_error("DevEui/MAC Len");

	$dpath = S_DATA . "/$mac";                // Device path global
	$xlog = "(lxu_ltxlora_v1)";                 // Script name for log

	if (@file_exists("$dpath/cmd/dbg.cmd"))  if (!$dbg) $dbg = 1;

	if (!isset($api_key)) exit_json_error("API Key"); // Required
	$dapikey = @file_get_contents("$dpath/dapikey.dat"); // false or KEY
	if ($dapikey === false || strcmp($api_key, $dapikey)) { //
		include("conf/check_dapikey.inc.php"); // only on demand: check external, opt. set daksave
		if ($dapikey === false || strcmp($api_key, $dapikey)) exit_json_error("API Key");
	}

	if (check_dirs()) exit_json_error("Error (Directory/MAC not found)");
	if (isset($daksave)) file_put_contents("$dpath/dapikey.dat", $dapikey); // Update key

	// For debug: blackbox-payloads
	if ($dbg) {
		if (@filesize("$dpath/dbg/indata.log") > 100000) {	// Main LOG
			@unlink("$dpath/dbg/indata.log/_indata_old.log");
			rename("$dpath/dbg/indata.log", "$dpath/dbg/indata.log/_indata_old.log");
		}
		file_put_contents("$dpath/dbg/indata.log", $now_str . ":\n" . $payload . "\n\n", FILE_APPEND);
	}

	// Isolate important variables
	$timestr = $data['time'] ?? $data['received_at'] ?? '';
	$unix_ts = strtotime($timestr);
	if ($unix_ts < 1000000000) exit_json_error("Illegal date");

	$object = $data['object'] ?? $data['uplink_message']['decoded_payload'] ?? null; // CS ?? TTN ?? illegal
	$fcnt = $data['fCnt'] ?? $data['uplink_message']['f_cnt'] ?? '-199';

	$rxInfo = $data['rxInfo'] ?? $data['uplink_message']['rx_metadata'] ?? null;
	if ($rxInfo !== null) {
		$rssi = -199;
		$snr = -199;
		// Find strongest signal
		foreach ($rxInfo as $rxs) {
			if ($rxs['rssi'] > $rssi) {
				$rssi = $rxs['rssi'];
				$snr = $rxs['snr'] ?? '(?)'; // Missing SNR sometimes happen
			}
		}
		if ($fcnt < 0 || $rssi == -199 || $snr == -199) $paylog = true;
	} else $paytrigger = false;

	// Working variables
	$maxlen = strlen(base64_decode($data['data'] ?? '')); // Uploaded data payload
	$devi = read_ini("$dpath/device_info.dat");
	$devi['now'] = $now;
	$devi['pasync'] = '1';    // LORA may be asynchronous (and no disconnect)
	// First of all: quota per UTC-day (in bytes) only for info
	$day = floor($now / 86400); // intdiv >= PHP7
	if (@$devi['day'] != $day) { // new day, new quota
		@$devi['total_in'] += @$devi['quota_in'];    // Keep olds...
		@$devi['total_out'] += @$devi['quota_out']; // out: *todo* 
		$devi['day'] = $day;
		$devi['quota_in'] = $maxlen;
		$devi['quota_out'] = 0;
		$devi['dpack0'] = $fcnt;	// First packet for this day
	} else {
		$devi['quota_in'] += $maxlen;
	}
	$ccnt = @$devi['trans'];
	if (!isset($ccnt)) $ccnt = 1;
	else $ccnt++;
	$devi['trans'] = $devi['conns'] = $ccnt;

	// Extract known units to array
	$known_units = [];
	$wnunits = false;
	$akunits = @$devi['kunits'];
	if (isset($akunits)) {
		$kunits =  explode(' ', $akunits);
		foreach ($kunits as $ku) {
			$tmp = explode(":", $ku);
			$known_units[$tmp[0]] = $tmp[1];
		}
	} else $wnunits = true; // In any case write

	// ----- LTX Payload START -----
	if ($object !== null) {
		// Generate data line (and units)
		$line = "!$unix_ts";
		$units = "!U";
		$reason = 2;  // Assume AUTO

		// Add chans from LTX payload
		foreach ($object['chans'] as $chan) {
			$idx = intval($chan['channel']);	// Chirpstack sends Float? Channel index
			$unit = @$chan['unit'];
			$val = @$chan['value'] ?? '?';
			$emsg = @$chan['msg']; // If set: Channel has ERROR
			$line .= " $idx:";
			if (isset($emsg)) $line .= $emsg;
			else $line .= $val;
			if (isset($unit)) {
				$unit = str_replace(' ', '', $unit); // No whitespace allowed
				$units .= " $idx:$unit";
				if (@$known_units[$idx] !== $unit) {
					$wnunits = true;
					$known_units[$idx] = $unit;
				}
			}
		}

		// Add HKs always available: 
		$frel = $fcnt - $devi['dpack0']; // Relative packet this day
		if ($frel < -199) {
			$frel = -199;
			$paylog = true;
		}
		$rpack = $frel;
		$line .= " 100:$rpack 102:$rssi 103:$snr";
		$units .= " 100:relNo 102:RSSI(dBm) 103:SNR(dB)";

		$edtdata = array($line . "\n");

		$ltxflags = $object['flags'];	// Only check (Reset), ignore rest
		if (strpos($ltxflags, '(Reset)') !== false) {
			array_unshift($edtdata, "<RESET>\n");
		}
		$ltxreason = $object['reason']; // Only show manual transmissions explicitly
		if (strpos($ltxreason, '(Manual)') !== false) {
			array_unshift($edtdata, "<NT MANUAL>\n");
			$reason = 3; // Manual
		}

		// Units changed?
		if ($wnunits) {
			$known_units[100] = 'relNo';
			$known_units[102] = 'RSSI(dBm)';
			$known_units[103] = 'SNR(dB)';
			$akunits = "";
			foreach ($known_units as $kk => $kv) {
				$akunits .= " $kk:$kv";
			}
			$devi['kunits'] = trim($akunits);
			$cookie = $now;
			$devi['cookie'] = $cookie;
			array_unshift($edtdata, $units . "\n");
			array_unshift($edtdata, "<COOKIE $cookie>\n");
		}
	} else $paytrigger = false;
	// ----- LTX Payload END -----

	write_ini("$dpath/device_info.dat", $devi);

	if ($paytrigger) {
		$ftemp = gmdate("Ymd_His", $now) . '_lora.edt'; // No file pos
		file_put_contents("$dpath/in_new/" . $ftemp, $edtdata);
		add_data($edtdata);
	} else { // e.g. MIC commands or battery level or ..
		$xlog .= "(Payload ignored)";
		$paylog = true; // but log it (DBG)
	}

	$mtrun = round((microtime(true) - $mtmain_t0) * 1000, 4);
	$xlog .= "(Run:$mtrun msec)"; // Add old log script runtime
	$okreply = array("status" => "ok");
	if ($dbg) $okreply['xlog'] = $xlog;

	if ($paylog) $xlog .= "(PAYLOG:'\n$payload\n')"; // Special cases into log

	add_logfile(); // Regular exit, entry in logfile should be first

	// Send simple confirmation
	echo json_encode($okreply);

	if ($paytrigger) {
		$xlog .= call_trigger($mac, $reason);
	}
} catch (Exception $e) {
	$errm = $e->getMessage();
	exit_json_error($errm);
}
// ***
